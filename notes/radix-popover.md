# Radix Popover

## Radix Popover 쓰는 이유

Radix Popover를 사용하는 건 편리함 뿐만 아니라 안정성을 함께 확보하기 위해서.
직접 구현하면 제어해야 할 변수가 너무 많고, 사소한 누락으로도 품질이 무너질 수 있음.
Radix는 접근성 표준, 스크롤 락, 포커스 트랩, 외부 클릭 등
이 모든 부분을 명세 기반으로 안정적으로 처리하기 때문에,
대부분의 실무 환경에서는 “직접 구현”보다 “Radix 기반 확장”이 더 합리적이다.

스타일링 자유도 또한 높다.

### 팝오버 요소를 순수 구현할 때 고려해야 하는 세부 사항들

- 바디 스크롤 막기 / 스크롤 위치 유지
- 바디 영역 클릭 차단(pointer-events)
- 중첩 모달 시 스크롤 락 중첩 관리
- 포탈 사용 시 올바른 위치 계산 및 방향 반전
- 외부 클릭·ESC 감지 후 안전한 dismiss 처리
- 접근성(포커스 트랩, aria-role, 키보드 내비게이션)

각 요소만으로 복잡도가 있는 로직들로,
모두를 직접 구현하면 각 기능이 서로 얽히며 버그가 생기기 쉽고 유지보수가 어려워진다.

### 직접 구현 시

| 항목                 | 직접 구현 시                                                       |
| -------------------- | ------------------------------------------------------------------ |
| **Body 스크롤 제어** | overflow hidden 수동 관리, 중첩 시 꼬일 위험                       |
| **Body 클릭 제어**   | 활성 레이어 외 모든 요소에 pointer-events: none을 직접 토글해야 함 |
| **외부 클릭 감지**   | useRef + mousedown 이벤트 직접 처리                                |
| **중첩 모달 처리**   | lockCount 등 전역 관리 필요                                        |
| **포지션/방향 계산** | getBoundingClientRect + 수동 계산                                  |
| **접근성(A11y)**     | aria, tabIndex, ESC 제어 직접 작성                                 |
| **유지보수**         | 각 기능 간 충돌 위험 높음                                          |
| **생산성**           | 구현과 테스트에 시간 소모                                          |

## 여담

플로팅 요소의 Radix 헤드리스 컴포넌트들은 다운로드 수를 보니 거의 반쯤은 표준으로 자리잡은 것 같다.
